学过数据库理论的读者，都应该还记得关于CHAR和VARCHAR的性能对比：CHAR比VARCHAR更快，因为CHAR是固定长度的，而VARCHAR需要增加一个长度标识，处理时需要多一次运算。

针对这种情况，我做了一下基准测试，基准测试环境如下：
【硬件配置】
硬件
配置
CPU
Intel(R) Xeon(R) CPU E5620 主频2.40GHz， 物理CPU 2个，逻辑CPU 16个
内存
24G（6块 * 4G  DDR3 1333 REG）
硬盘
300G * 3个，SAS硬盘 15000转，无RAID，有RAID卡，且开了回写功能
OS
RHEL5
MySQL
5.1.49/5.1.54
【MySQL配置】
配置项
配置
innodb_buffer_pool_size
18G
innodb_log_file_size 
200M
innodb_log_files_in_group 
3
sync_binlog
100
innodb_flush_log_at_trx_commit
2
【表配置】
VARCHAR平均长度200，CHAR长度250，其它配置如下：
配置项
配置
记录数
1000万，2000万，5000万，1亿
存储引擎
Innodb
行格式
compact
性能测试结果如下：
【查询】


【插入】


【更新】
更新时VARCHAR也是随机长度


【删除】


测试结果展现了一个与理论不太相符的现象：当表大小小于Innodb buffer pool时，CHAR和VARCHAR没有差别，而在表大小大于Innodb buffer pool时，VARCHAR性能反而更高！这是为什么呢？

首先，性能是综合硬件、配置、表记录数、业务模型等多种因素综合后的结果，单一因素的差异，对整体来说可能几乎没有影响；
例如，执行一个操作需要100ms，而CHAR 比 VARCHAR性能上只快了1微秒，那么最终的性能就不会有影响。
这就是当Innodb buffer pool足够大时，CHAR 和VARCHAR没有差别的原因。

再次，理论上CHAR比VARCHAR快的根本原因是站在CPU的角度来说的，但性能是综合各种因素后的最终结果，当Innodb buffer pool小于表大小时，"磁盘读写"成为了性能的关键因素，而VARCHAR更短，因此性能反而比CHAR高。

最后，有朋友可能会认为，VARCHAR更新时如果新的数据比旧的数据要长，可能需要移动数据，导致性能更低；从实测结果来看，这种操作对最终的性能也是没有明显影响的。可能是因为Innodb采用页管理数据，数据移动是先在内存里完成，再写到磁盘，因此数据即使移动也很快。

【应用技巧】
基于以上测试结果和分析，我个人认为一般情况下优先使用VARCHAR，特别是字符串的平均长度比最大长度要小很多的情况；
当然，如果你的字符串本来就很短，例如只有10个字符，那么就优先选CHAR了。

附：
1）有兴趣的朋友可以推断一下：为什么测试结果中10KW的表性能，VARCHAR比CHAR快大约20%？
2）测试数据只为对比用，不代表一般情况下MySQL的性能就这么高，因为为了能够对比，测试时做了很多准备工作，测试操作也是比较特殊的。






7楼 Skier 2013-08-07 15:46发表 [回复]

char比varcha的优势在于update不会产生磁盘碎片。
lz的机器过于强劲，我怀疑是所有的操作都是在内存中进行的。
希望楼主能补充几个试验。
1. 带有回写的update测试。
2. update完之后，select sql_no_cache读取varchar；这个时候varcha有大量的随便，读取速度应该比char慢。
3. char和varcha在做索引的时候性能不同，期待能验证一下。
Re: 爱技术的华仔 2013-08-08 18:18发表 [回复]

回复Skier：1) 1亿记录的时候，innodb buffer pool已经无法将数据全部缓存，大部分都是磁盘操作，所以性能急剧下降
2) 碎片问题理论上肯定是有影响的，但从实测来看，看不出有很大影响
3) 建索引的性能差异，也是站在CPU和内存的角度来说的，综合磁盘的影响，CPU和内存的可以忽略不计。
归根结底，长度、碎片、索引的影响，都比不上磁盘的影响，因为磁盘的性能是ms级的，CPU和内存都是ns级的。
6楼 oneyearlater 2012-06-23 21:00发表 [回复]

不仅如此，datetime（8B） 和 timestamp (4B) 也是如此，datetime的读写性能要好过比它短的timestamp，奇怪吧，mysql对timestamp做了些额外的转换，导致它很慢
Re: 爱技术的华仔 2012-06-25 10:11发表 [回复]

回复oneyearlater：学习了。。。。。。：）
5楼 afive 2011-12-12 09:53发表 [回复]

数据库的记录数为１亿的条件下，　性能下降的怎么这么厉害？
Re: 爱技术的华仔 2011-12-14 23:39发表 [回复]

回复afive：1亿条时，表的大小加索引的大小是40多G吧，超出了内存大小，性能下降很大
Re: oneyearlater 2012-06-23 21:15发表 [回复]

回复yah99_wolf：“有兴趣的朋友可以推断一下：为什么测试结果中10KW的表性能，VARCHAR比CHAR快大约20%？” 是不是和以下3点有关 

1） innodb的索引和data是放在一块的，40G的容量当中，当内存不足时候，非主键索引会被换到磁盘上，

2） 由于innodb 对创建索引的列有767 字节的限制，即使创建成功也是，取前255字节做前缀索引。

3） 楼主给出的条件当中“VARCHAR平均长度200，CHAR长度250”

此时按需增长的VARCHAR的索引比CHAR 要少 20 % ， 所以导致了“VARCHAR比CHAR快大约20% ！！！”

是这样吧 ：-D
Re: 爱技术的华仔 2012-06-25 10:10发表 [回复]

回复oneyearlater：我的理解应该是第三条，因为此时磁盘读写成了性能瓶颈，varchar更短，所以更快
4楼 kylidboy 2011-12-09 14:33发表 [回复]

我记得MYSQL的手册上有一句话说，INNODB用VARCHAR比较好，这和它的树形结构有关？不知道，随便猜猜
3楼 sbkyv 2011-12-08 21:22发表 [回复]

你在char和varchar做个索引就知道性能差别了
Re: 爱技术的华仔 2011-12-09 17:54发表 [回复]

回复sbkyv：具体是什么差别？
2楼 黄传通 2011-12-07 11:35发表 [回复] [引用] [举报]

varchar与char在内存申请中的表现都是一致，以最大数去申请，不是以实际长度申请；即，char（255）与varcahr（255）即使都只存一个字符A，都要申请内存255个单位。其二，硬盘空间申请，char是固定申请你定义的长度，如char（250），就统一是不是250，很浪费硬盘空间与效率的。反而varchar只申请所需的硬盘空间，动态扩展。
详细去看源码吧～～～
Re: 爱技术的华仔 2011-12-09 17:54发表 [回复]

回复toontong：底层实现倒没有仔细去看，从业务角度来测试，黑盒测试
Re: 无天 2011-12-09 17:46发表 [回复] [引用] [举报]

回复toontong：soga.
